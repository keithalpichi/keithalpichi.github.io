{"data":{"markdownRemark":{"html":"<p>In <a href=\"/blog/learning-go-for-nodejs-engineers-part-1\">Part 1</a> we covered the following Go topics:</p>\n<ul>\n<li>compiled language type</li>\n<li>static type system</li>\n<li>zero-values</li>\n<li>dependency management</li>\n<li>importing and exporting packages</li>\n<li>compiling and executing Go binaries and packages</li>\n<li>structs, arrays, slices, maps</li>\n<li>flow control</li>\n<li>type checking and assertions</li>\n</ul>\n<p>In Part 2 we will cover:</p>\n<ul>\n<li>pointers &#x26; pointer receivers</li>\n<li>interfaces</li>\n<li>error handling</li>\n<li>concurrency</li>\n</ul>\n<h2>Pointers</h2>\n<p>One major difference between Javascript and Golang is the concept of pointers. In Javascript, you don't have to worry about pointers. Everything, except arrays and objects, is passed by its value. For example:</p>\n<pre><code>function changeHobby(old) {\n  old = \"golang\"\n}\nlet old = \"node\"\nchangeHobby(old)\nconsole.log(old === \"golang\") // prints false\n</code></pre>\n<p>The function <code>changeHobby</code> mutates the <code>old</code> argument. The changes are only applied to that scoped variable and not to the same named variable outside the function because it was copied to it. The same functionality applies to this function if it was translated to Golang.</p>\n<pre><code>func changeHobby(old string) {\n  old = \"golang\"\n}\nold := \"node\"\nchangeHobby(old)\nfmt.Println(old == \"golang\") // prints false\n</code></pre>\n<h3>Pointers and Functions</h3>\n<p>In Golang, you can mutate the value at the address of a variable by using a pointer. A pointer is an object that contains the memory location of a variable.</p>\n<pre><code>func changeHobby(old *string) {\n  *old = \"golang\" // go to the memory address and change it\n}\nold := \"node\"\nchangeHobby(&#x26;old) // provide a pointer\nfmt.Println(old == \"golang\") // prints true\n</code></pre>\n<p>We provide <code>changeHobby</code> a pointer as an argument. It then takes the value at the address of <code>old</code> and replaces it with \"golang\".</p>\n<blockquote>\n<p>Pro Tip: The <code>&#x26;</code> operator references the address of a value and the <code>*</code> operator references the value at an address. I like the think the \"a\" in ampersand represents the \"a\" in address. This helps me differentiate between the two.</p>\n</blockquote>\n<h3>Pointers and Methods</h3>\n<p>In Javascript, you can change instance properties by simply changing it. Consider this pseudoclass:</p>\n<pre><code>const Dude = function(hobby) {\n  this.hobby = hobby\n}\n\nDude.prototype.changeHobby = function(newHobby) {\n  this.hobby = newHobby\n}\n\nconst dude = new Dude(\"node\")\ndude.changeHobby(\"golang\")\ndude.hobby === \"golang\" // returns true\n</code></pre>\n<p>In Go, you use <a href=\"https://tour.golang.org/methods/4\"><strong>pointer receiver methods</strong></a> to mutate the field values of a struct. For example:</p>\n<pre><code>type Dude struct {\n  Hobby string\n}\n\nfunc (d *Dude) changeHobby(h string) {\n  d.Hobby = h\n}\n\nd := Dude{\"node\"}\nd.changeHobby(\"golang\")\nd.Hobby == \"golang\" // returns true\n</code></pre>\n<p>The method <code>func (d *Dude) changeHobby</code> is a pointer receiver method and uses a pointer (<code>d</code>) to mutate the values on the <code>Dude</code> struct. </p>\n<blockquote>\n<p>Pro Tip: The obvious use case for pointer receiver methods is to mutate the receiver. If in doubt, use a pointer receiver. Learn more about when to use pointer receiver methods in the <a href=\"https://github.com/golang/go/wiki/CodeReviewComments#receiver-type\">Go wiki</a></p>\n</blockquote>\n<h2>Interfaces</h2>\n<p>Javascript doesn't have the concept of interfaces. A Go interface is a set of method signatures. An interface describes the behavior of a type. Any type that implements <em>every</em> method in an interface definition is considered to satisfy that interface. Let's look at an example.</p>\n<pre><code>type Talker interface {\n  Greet() string\n}\n</code></pre>\n<p>The <code>Talker</code> interface has one method, <code>Greet</code> that returns a string. Let's satisfy this interface now.</p>\n<pre><code>type Human struct {}\nfunc (h *Human) Greet() string {\n  return \"Hello\" \n}\n</code></pre>\n<p>With the concept of interfaces your code can be flexible and extendible. Take this function, for example:\nfunc Greet(t Talker, name string) string {\nreturn t.Talk() + \", \" + name\n}\nIt accepts the Talker interface and a string. Any type that satisfies the Talker interface can be provided to the Greet function. Any that does not will fail compilation.\nh := Human{}\ngreeting := Greet(h, \"dog\") // \"Hello, dog\"\nLet's add another struct type that satisfies this interface to show how\ntype Dog struct {}\nfunc (d *Dog) Greet() string {\nreturn \"Bark\"\n}\nPro Tip: Interfaces\nError Handling\nIn Javascript, there are various ways to handle errors and exceptions. Depending on your approach you can use try/catch and throw, the error argument in a callback, or the catch in Promises.\nIn Golang, errors are treated differently. Ther\nit's idiomatic to handle errors immediately and relay them back to the caller. The format of this is to return two values for the caller to handle. One is for the success, the other is for the failure. Does this sound like how the success and error arguments in a callback or the then and catch in Promises are handled? Yeah, it does!\nThe main difference is that Javascript calls the callback with the success and error values where as in Golang the called function handles and/or modifies the error then returns it back to the calling function.\nLet's see an example:\nfunc drink(c int) (string, error) {\nif c &#x3C; 1 {\nreturn \"\", fmt.Errorf(\"cannot drink less than %d cups\", c)\n}\nreturn \"Slurp\", nil\n}\nIf the argument c is less than 1, we return an empty string and an error. Since this function knows how the error occurred it formats (using fmt.Errorf to format a string with helpful information). If the argument is not less than 1, we return a non-empty string and a nil error. Then when you call this function you can check for an error and handling it accordingly like this:\nsound, err := drink(1)\nif err != nil {\n// handle the error here\n}\n// use \"sound\" and \"err\" here\nPro Tip: Handle errors immediately to keep code vertical and left-aligned. This will prevent nested code, thus making it more readable.\nJust like how the drink function handled the error, if the caller finds an error it can use the error programmatically, modify it, and possibly send it back to it's calling function.\nFurthermore, you can declare variables to use within conditionals like this:\nif sound, err := drink(1); err != nil {\n// handle the error here\n} else {\n// use \"sound\" here\n}\nThis is called a compound if-statement and it is super helpful if you only need the variables within the conditional and not outside it. After this conditional, the two variables sound and err are not accessible because they'll be garbage collected.\nTry/Catch\nPut simply, panic and recover behave similar to Javascript's try/catch but their use cases are different.Panic stops the ordinary flow of control and begins panicking. Recover allows you to regain control of a panic. Recover is only useful inside deferred functions.\nDefer\nWhen ever you need to perform clean-up actions such as closing files or HTTP requests you're encouraged to use the defer function. In NodeJS, you must remember to close a file after you're done reading it and when ever an error is encountered. In Golang, you'll often use defer to push a function onto the call stack to execute when the encompassing function finishes executing. For example:\nfunc getNameByID(id string) (string, error) {\nclient, err := createDBClient('127.0.0.1:7000')\nif err != nil {\nreturn \"\", err\n}\ndefer client.Close()\nreturn client.GetUserName(id)\n}\nThis impractical function creates a database client to get a user name. As soon as we create this client we \"defer\" the close until after this function finishes. No matter what happens within this function, good or bad, the function client.Close will always execute.\nThere are other, more practical, use cases of defer (like providing arguments to the deferred function and utilizing recover), panic, and recover but they're a bit out of the scope of this article (read more about panic and recover to learn more).\nPro Tip: Start adopting these error handling practices early with the success return value on the left and the failure value on the right. If you need to return multiple success values, the failure value is always right-most value.\nConcurrency\ngoroutine\nchannel</p>\n<p>The Reasons I Love Go\nSimple, light-weight, expressive, and it's easy to learn\nThe standard library is comprehensive and well-built\nConcurrency is super easy to get started with and use\nThe Go blog is very active and informative (HINT: read them all)</p>\n<p>Want to Keep Learning?\nI knew you'd ask. The following resources are the perfect place to start.\n<a href=\"https://golang.org/doc\">https://golang.org/doc</a>\n<a href=\"https://github.com/golang/go/wiki\">https://github.com/golang/go/wiki</a></p>","frontmatter":{"title":"Learning Go - For NodeJS Engineers (Part 2)","date":"2019-04-28T08:00:00.000Z","tags":["golang","javascript","nodejs"]}}},"pageContext":{}}