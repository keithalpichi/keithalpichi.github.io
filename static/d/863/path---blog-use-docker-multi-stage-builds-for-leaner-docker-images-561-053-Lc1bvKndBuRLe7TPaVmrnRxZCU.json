{"data":{"markdownRemark":{"html":"<p>Traditionally, building Docker images required complex instructions in a single Dockerfile, or sometimes many Dockerfiles, to create a final optimized Docker image. This complexity made it difficult to maintain Dockerfiles and create lean Docker images.</p>\n<p>To alleviate this complexity, Multi-Stage Builds was introduced as a feature in Docker version 17.05. Today, we'll look at a common, but simplified, Docker problem and resolve the complexities of this problem with the help of Multi-Stage Builds.</p>\n<h2>The Problem</h2>\n<p>To better grasp the problem let's see an example. We are building a Docker image to watch for files that are added to and removed from a directory. Here is the Typescript source code for the program.</p>\n<pre><code>import * as chokidar from 'chokidar'\nconst dirToWatch = '/watch'\nconst watcher = chokidar.watch(dirToWatch, {\n  persistent: true\n});\nconst log = console.log.bind(console);\nwatcher\n  .on('add', path => log(`File ${path} has been added`))\n  .on('addDir', path => log(`Directory ${path} has been added`))\n  .on('unlink', path => log(`File ${path} has been removed`))\n  .on('unlinkDir', path => log(`Directory ${path} has been removed`))\n  .on('error', error => {\n    log(`Watcher error: ${error}`)\n    process.exit(1)\n  });\n</code></pre>\n<p>This program is simple. We're using the Chokidar library to achieve the functionality of watching filesystem events. It watches the /watch directory for files and directories that are added and removed. When an event happens, we print a simple message to stdout.\nHere are all of our files to build and run this program:\nindex.ts\npackage.json\ntsconfig.json\nDockerfile\nWe have the source code in index.ts, the NPM dependencies in package.json, the Typescript build configuration in tsconfig.json, and the Dockerfile. Let's edit the Dockerfile to build this image. I'll make sure to add some common, yet suboptimal, operations in this file.\nFROM node:12.13.0-alpine\nWORKDIR /app\nCOPY . .\nRUN npm install --quiet\nRUN ./node_modules/typescript/bin/tsc\nENTRYPOINT [ \"node\" ]\nCMD [\"index.js\"]\nHere we perform the following steps:\nuse the node:12.13.0-alpine image as the base image. This gives us npm and node.\nset the working directory to /app.\ncopy the entire current working directory on the host into the /app directory in the image.\ninstall the dependencies listed in package.json. This includes some Typescript development dependencies and the Chokidar library.\ncompile the Typescript code to Javascript.\nset the Docker entry point and command steps.</p>\n<p>Let's build this image now.\ndocker build -t fs-watcher .\nOn my system, it builds a 144MB Docker image. Not bad but can we do better? Sure. There are two big improvements we can apply:\nReduce files on disk- only copy into the image the appropriate files that compile the source code.\nReduce Docker layers- each FROM, COPY , RUN , CMD adds a layer. Each Docker layer adds to the total Docker image size. We can reduce the image size by combining multiple RUN commands into one using multiple &#x26;&#x26;.</p>\n<p>Let's apply those two things now.\nFROM node:12.13.0-alpine\nWORKDIR /app\nCOPY index.ts package.json tsconfig.json /app/\nRUN npm install --quiet &#x26;&#x26; ./node<em>modules/typescript/bin/tsc\nENTRYPOINT [ \"node\" ]\nCMD [\"index.js\"]\nWe now only copied the index.ts, package.json, and tsconfig.json into the image. We've also joined the two RUN commands. Building it now doesn't change the size much (our application is small) but we now have fewer files in the image and one less layer that makes up the Docker image. If this Dockerfile were for a real production application that included more complex steps and we applied the same improvements, you'd see a noticeable decrease in image size.\nThe following files now exist within the working directory of the image:\nindex.ts\nindex.js\nnode</em>modules\npackage-lock.json\npackage.json\ntsconfig.json\nBetter but we can still make improvements. Let's add some steps in the Dockerfile to delete files we no longer need. This includes the NPM files and Typescript source code and configuration files.\nFROM node:12.13.0-alpine\nWORKDIR /app\nCOPY index.ts package.json tsconfig.json /app/\nRUN npm install --quiet &#x26;&#x26; <br>\n./node<em>modules/typescript/bin/tsc &#x26;&#x26; <br>\nrm -f index.ts package* tsconfig.json\nENTRYPOINT [ \"node\" ]\nCMD [\"index.js\"]\nWe add another step in the RUN command to remove all these unnecessary files. We also added a few \\ to put commands on each line because the line was getting very long. This is very common in Dockerfiles. After building the image with these changes the following files exist within the working directory of the image:\nindex.js\nnode</em>modules\nSweet! There now is a single entry file and the dependencies it needs. Looking back, the Dockerfile has improved a lot. However, there were a few odd steps we needed to perform to achieve this result. We had to:\nadd multiple commands into a single RUN instruction\nmake sure each command after the RUN instruction was in the right order\nadd multiple \\ to break many commands into separate lines\ncopy many files into the Docker image\nadd rm commands to remove files we no longer needed</p>\n<p>As your application gets more complex, the number of files and commands greatly increases. You end up having to remember to perform a ton of steps and make sure those steps are in the right order. If you aren't careful the complexity of the Dockerfile can contribute to large Docker images.\nI've even seen some codebases with different Dockerfiles based on the environment or need. Dockerfiles depended on others. Each Dockerfile was a little different and it would produce an image that copied dependencies from other images. Some Dockerfiles used volumes and mount points to allow the host to access the binaries or dependencies produced by the image so they could be copied to other images. It was a mess. It worked but it felt wrong.\nSo how do we eliminate all this complexity? With Docker's Multi-Stage Builds.\nThe Solution\nMulti-Stage Builds helps optimize Dockerfiles while keeping them easy to read and maintain. Docker briefly describes this feature like this:\nWith multi-stage builds, you use multiple FROM statements in your Dockerfile. Each FROM instruction can use a different base, and each of them begins a new stage of the build. You can selectively copy artifacts from one stage to another, leaving behind everything you don't want in the final image.\nLet's break this down. With this feature, a single Dockerfile can now contain multiple stages. A stage is a section of the Dockerfile that starts with a FROM instruction.\nFROM node:12.13.0-alpine as install\nWORKDIR /install\nCOPY package.json /install/\nRUN npm install --quiet\nThe first line signifies the lines it precedes as a single stage. The instruction as install names this stage install. You don't have to name the stage but it helps in later stages to reference this stage by its name rather than the stage number; in this case zero since it is the first stage in Dockerfile. In this stage we:\nset the working directory to /install\ncopy the package.json to this directory\ninstall the dependencies listed in the package.json</p>\n<p>This stage is clear. It installs dependencies. We could stop and build this image if we wanted to but the final Docker image is not complete. We're still missing a lot of stages. Let's build the next stage.\nFROM node:12.13.0-alpine as compile\nWORKDIR /build\nCOPY tsconfig.json index.ts /build/\nCOPY --from=install /install/node<em>modules /build/node</em>modules\nRUN node<em>modules/typescript/bin/tsc\nWe've named this stage the compile stage. In this stage we:\nset the working directory to /build\ncopy the Typescript source code and compilation file into this directory\ncopy the dependencies in the /install/node</em>modules directory from the install stage to the /build/node_modules directory\ncompile the Typescript source code using thetsc compiler</p>\n<p>The main take away from this stage is the COPY --from=<stage> instruction. This does exactly as it says. It copies files from one stage into the current stage.\nWe now have two stages, install and compile. I'd like to pause here and explain another interesting feature of Multi-Stage Builds. When building an image you can tell Docker what stage to build up to. For example, if we ran docker build --target install . we'd only build the install stage. However, if we did not provide the --target <stage> it would build all the stages. Okay let's resume developing all the stages.\nHere is the final Dockerfile:\nFROM node:12.13.0-alpine as install\nWORKDIR /install\nCOPY package.json /install/\nRUN npm install --quiet\nFROM node:12.13.0-alpine as compile\nWORKDIR /build\nCOPY tsconfig.json index.ts /build/\nCOPY --from=install /install/node<em>modules /build/node</em>modules\nRUN node<em>modules/typescript/bin/tsc\nFROM node:12.13.0-alpine as source\nWORKDIR /app\nCOPY --from=compile /build/index.js /app/index.js\nCOPY package.json /app\nRUN npm install --production --quiet\nFROM node:12.13.0-alpine as dev\nWORKDIR /app\nCOPY --from=source /app/index.js .\nCOPY --from=source /app/node</em>modules node<em>modules\nVOLUME [ \"/watch\" ]\nENTRYPOINT [ \"node\" ]\nCMD [\"index.js\"]\nFROM node:12.13.0-alpine as prod\nWORKDIR /app\nCOPY --from=source /app/index.js .\nCOPY --from=source /app/node</em>modules node_modules\nRUN mkdir /watch\nENTRYPOINT [ \"node\" ]\nCMD [\"index.js\"]\nLet's briefly describe the last three stages:\nin the source stage we copy the the source code from the previous stage and install production dependencies.\nin the dev stage we copy the source code from the previous stage, add a volume, set the entry point and command. The volume allows us to test the program running in the Docker image. If we build up to this stage we can test the image by adding to or removing files from the volume on the host and assert that the program is working as expected.\nin the prod stage we copy the source code from the source stage, create a directory /watch , and set the entry point and command.</p>\n<p>The final Docker image on my system is ~80MB. That's nearly half the size of the first Docker image. If we wanted we could apply a few more changes to further reduce the size:\nbuild the base image from scratch and have complete control of the dependencies required to run our program\ncompile the source code to a binary executable</p>\n<p>Conclusion\nWe've come along way in improving our Dockerfiles and Docker images. Thanks to Multi-Stage Builds:\nwe've converted the many error-prone hacky (&#x26;&#x26; and ) and suboptimal steps in our Dockerfile into multiple stages.\neach stage provided clarity because it was concise.\ncopying artifacts from prior stages was simple. No intermediate Docker images were required to be built to disk.\neach stage could be built into a Docker image. You can use this to test each stage.\nthe final Docker image became leaner.</p>\n<p>So take a look at your current Dockerfiles and assess its complexity. Analyze how you can convert the many instructions and commands into a Multi-Stage Build. There is no better feeling than making Dockerfiles and Docker images maintainable.\n🤙 Mahalo for reading! I'd appreciate it if you recommend this post (by clapping for it 👏 ) and share it so other people can find it. If you enjoyed my article, please follow me.</p>","frontmatter":{"title":"Use Docker Multi-Stage Builds for Leaner Docker Images","date":"2019-11-18 08:00","tags":["docker"]}}},"pageContext":{}}