{"data":{"markdownRemark":{"html":"<p>When handling HTTP responses it is important to check the errors first before handling the responses. Even if you defer to close the <code>io.Closer</code>, in this case a response body, you’ll be surprised what happens when it is nil. Avoiding this crucial step or assuming defer can deflect or handle errors will lead to a nasty panic; ultimately crashing your program. Let’s see an example of this.</p>\n<h2>How To Do It Incorrectly</h2>\n<pre><code class=\"language-go\">res, err := http.Get(\"abc.com/coffee\")\ndefer res.Body.Close()\nif err != nil {\n    // handle `err`\n}\n// do something with `res`\n</code></pre>\n<p>If this function returns valid responses and nil errors you won’t experience any issues. Cool! That is, until <code>res</code> is nil. When it is you’ll get a panic that looks something like this:</p>\n<pre><code class=\"language-go\">PANIC: runtime error: invalid memory address or nil pointer dereference\n</code></pre>\n<p>If you follow the call stack you’ll be lead to the line <code>defer res.Body.Close()</code>. This error has occurred from trying to close a nil <code>io.Closer</code>. It just won’t work, it’s impossible.</p>\n<h2>How To Do It Correctly</h2>\n<p>By simply checking for an error before doing anything with the response we can conclude what we can and cannot do next.</p>\n<ul>\n<li>if the error is not nil, we have an error and the response is nil. Return now or continue but avoid using the nil response</li>\n<li>if the error is nil, we don’t have an error and the response is not nil. We can freely use the response as we originally intended</li>\n</ul>\n<p>Our code could then look like this:</p>\n<pre><code class=\"language-go\">res, err := http.Get(\"abc.com/coffee\")\nif err != nil {\n    return err\n}\ndefer res.Body.Close()\n// continue to use `res`\n</code></pre>\n<p>As you can see we’ve handled the error first and returned if it was not nil. Otherwise we continued to use the response.</p>\n<h2>Conclusion</h2>\n<ul>\n<li>always check errors immediately after functions that return them</li>\n<li><code>defer</code> should only prepend non-nil functions</li>\n<li><code>defer</code> does not deflect or handle errors automatically. You can, however, handle them with <code>recover</code></li>\n</ul>","frontmatter":{"title":"Go Gotcha: Closing a Nil HTTP Response Body With Defer","date":"2018-05-16T15:00:00.000Z","tags":["golang"]}}},"pageContext":{}}