{"componentChunkName":"component---src-templates-article-tsx","path":"/blog/what-is-express-middleware-and-how-to-create-one","result":{"data":{"markdownRemark":{"html":"<h4>Prerequisites</h4>\n<ul>\n<li>Basic understanding of the HTTP protocol, Javascript, Node, and Express</li>\n</ul>\n<h2>What are Middlewares?</h2>\n<p>From the documentation,</p>\n<blockquote>\n<p>Middlewares are functions that have access to the request object (req), the response object (res), and the next function in the applicationâ€™s request-response cycle. The next function is a function in the Express router which, when invoked, executes the middleware succeeding the current middleware.</p>\n</blockquote>\n<p>To give you a relatable picture, Express middleware's are the workers in a manufacturing line where each individual has a specific and unique responsibility. When a worker receives a product (request) from a previous worker they can do <strong>one</strong> of the following:</p>\n<ul>\n<li><strong>reject</strong> the product if it doesn't meet strict standards, thus the product ceases to continue down the production line</li>\n<li><strong>add to or manipulate</strong> the product and/or <strong>allow</strong> the product to continue down the production line where the next worker (middleware) does their job</li>\n</ul>\n<p>If you've used Express before, you may have used some <a href=\"https://expressjs.com/en/resources/middleware.html\">middlewares</a>:</p>\n<ul>\n<li>'body-parser'- parses the request body and places it into the 'req.body' key of the request object</li>\n<li>'express.static'- serves your static files</li>\n<li>'express.logger'- uses a logger</li>\n</ul>\n<p>All you had to do was add these to your Express application or route and BAM... you had more functionality! It seemed like magic but it's actually quite simple.</p>\n<p>In this article I'll go over the details of middlewares and some useful examples showcasing the flexibility and power of middlewares.</p>\n<h2>Req, Res, Next</h2>\n<p>Middlewares have access to three things:</p>\n<ul>\n<li>the <a href=\"https://expressjs.com/en/4x/api.html#req\">request</a> object</li>\n<li>the <a href=\"https://expressjs.com/en/4x/api.html#res\">response</a> object</li>\n<li>the 'next' function</li>\n</ul>\n<pre><code class=\"language-go\">function customMiddleware (req, res, next) {\n  //...\n}\n</code></pre>\n<p>Since you have access to the request and response you can do almost anything you want. You can extract or add information to and from either one. You would call 'next( )' if you want to continue the request and pass it on to the next middleware or end the request right there.</p>\n<h2>Middleware Chain</h2>\n<p>So you created the custom middleware, now what? You add it to the middleware chain. <strong>Middlewares are called in the order they're declared</strong>.</p>\n<pre><code class=\"language-go\">const express = require('express')\nconst app = express()\napp.use(express.bodyParser)\napp.use(customMiddleware)\n</code></pre>\n<p>On every request these two middlewares will run- 'bodyParser' will run first before the one below it</p>\n<pre><code class=\"language-go\">const express = require('express')\nconst app = express()\napp.get('/some/path', customMiddleware, customMiddleware2)\n\nconst apiRouter = express.Router()\napiRouter.use(customMiddleware2)\napp.use('/api', apiRouter)\n</code></pre>\n<p>You can have middlewares run on specific routes.</p>\n<ul>\n<li>'customMiddleware' will run first followed by 'customMiddleware2' for the 'GET' method on the path '/some/path'</li>\n<li>Only 'customMiddleware2' will run for all requests to the 'apiRouter'</li>\n</ul>\n<p>Cool huh? Let's see some other useful examples!</p>\n<h2>A Simple Logger- Log Date and URL Path</h2>\n<p>In this example I extract and log some data specific to the request, then pass the request to the next middleware by using the 'next' function. The request or response is not altered in any way. I'll show an example of that next.</p>\n<pre><code class=\"language-go\">function datePathLogger (req, res, next) {\n  const date = new Date().toUTCString()\n  console.log(`Request to '${req.path}' on ${date}`)\n  next()\n}\n</code></pre>\n<p>A request to a url 'www.foo.com/bar' would log</p>\n<pre><code class=\"language-bash\">Request to '/bar' on Mon, 17 Jul 2017 01:01:38 GMT\n</code></pre>\n<p>After the 'console.log' function ran the 'next' function was called. At this point the request and response would be handed to the next middleware.</p>\n<h2>Token Parser- Parse User ID from JWT Token</h2>\n<p>In this example I parse the request object for the JWT token to get the user's id. If it doesn't exist or the token was invalid I end the request and send back an unauthorized status code of 401. At this point the request stops. If it does exist I place the user's id into 'req.user_id' then call 'next'.</p>\n<blockquote>\n<p>Note that the key 'user<em>id' is arbitrary. I could have used 'req.users</em>identification_number'. However, there are reserved keys on the request and response object that you shouldn't modify. So consult the documentation to verify you're not modifying reserved keys.</p>\n</blockquote>\n<pre><code class=\"language-go\">function tokenParser (req, res, next) {\n  const user_id = parseTokenForUserID(req) // This is a made-up function that parses the user's ID from the request object\n  if (!user_id) {\n    res.sendStatus(401)\n  } else {\n    req.user_id = user_id\n    next()\n  }\n}\n</code></pre>\n<p>Now in every succeeding middleware or request handler I have access to the user's id at 'req.user_id'.</p>\n<h2>Environment-specific Middleware</h2>\n<p>Since middleware's are just functions you can have functionality based on different environments or configuration. Say, for example, we wanted to perform descriptive logging for development environments.</p>\n<pre><code class=\"language-go\">function logger (env) {\n  if (env === 'development') {\n    return function (req, res, next) {\n      // perform descriptive logs better suited for development environments\n    }\n  } else {\n    return function (req, res, next) {\n      // perform none or minimal logging\n    }\n  }\n}\n</code></pre>\n<p>Then add this middleware by <strong>calling</strong> it with the environment</p>\n<pre><code class=\"language-go\">const express = require('express')\nconst app = express()\napp.use(logger(process.env.NODE_ENV))\n</code></pre>\n<p>These may not be practical examples you'd actually use in production but the illustrations should provide some clarity on the flexibility of middlewares.</p>\n<h2>Beauty Of Middlewares</h2>\n<p>I love how the flow in Express middleware's are very explicit. It makes code intuitive, super flexible, and easy to read. If you're not creating custom middlewares I highly encourage you take advantage of their simplicity and power.</p>\n<p>If you have any comments or questions please tweet me!</p>","frontmatter":{"title":"What is an Express Middleware and How to Create One","date":"2017-07-17T12:00:00Z","tags":["express","nodejs"]}}},"pageContext":{}},"staticQueryHashes":[]}